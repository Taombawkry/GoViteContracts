// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createCryptoPaymentOptionToken = `-- name: CreateCryptoPaymentOptionToken :one
INSERT INTO crypto_payment_option_tokens (
    crypto_payment_option_id,
    network_id,
    token_id
) VALUES (
    $1, $2, $3
)
RETURNING id, crypto_payment_option_id, network_id, token_id
`

type CreateCryptoPaymentOptionTokenParams struct {
	CryptoPaymentOptionID int32
	NetworkID             int32
	TokenID               int32
}

func (q *Queries) CreateCryptoPaymentOptionToken(ctx context.Context, arg CreateCryptoPaymentOptionTokenParams) (CryptoPaymentOptionToken, error) {
	row := q.db.QueryRowContext(ctx, createCryptoPaymentOptionToken, arg.CryptoPaymentOptionID, arg.NetworkID, arg.TokenID)
	var i CryptoPaymentOptionToken
	err := row.Scan(
		&i.ID,
		&i.CryptoPaymentOptionID,
		&i.NetworkID,
		&i.TokenID,
	)
	return i, err
}

const createDistribution = `-- name: CreateDistribution :one
INSERT INTO distributions (
    network_id,
    crypto_payment_option_id,
    description,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
) RETURNING id, network_id, crypto_payment_option_id, description, created_at, updated_at
`

type CreateDistributionParams struct {
	NetworkID             int32
	CryptoPaymentOptionID int32
	Description           sql.NullString
}

func (q *Queries) CreateDistribution(ctx context.Context, arg CreateDistributionParams) (Distribution, error) {
	row := q.db.QueryRowContext(ctx, createDistribution, arg.NetworkID, arg.CryptoPaymentOptionID, arg.Description)
	var i Distribution
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.CryptoPaymentOptionID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createDistributionSplit = `-- name: CreateDistributionSplit :one
INSERT INTO distribution_splits (
    distribution_id,
    wallet_address,
    name,
    split_percentage,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
) RETURNING id, distribution_id, wallet_address, name, split_percentage, created_at, updated_at
`

type CreateDistributionSplitParams struct {
	DistributionID  int32
	WalletAddress   string
	Name            sql.NullString
	SplitPercentage string
}

func (q *Queries) CreateDistributionSplit(ctx context.Context, arg CreateDistributionSplitParams) (DistributionSplit, error) {
	row := q.db.QueryRowContext(ctx, createDistributionSplit,
		arg.DistributionID,
		arg.WalletAddress,
		arg.Name,
		arg.SplitPercentage,
	)
	var i DistributionSplit
	err := row.Scan(
		&i.ID,
		&i.DistributionID,
		&i.WalletAddress,
		&i.Name,
		&i.SplitPercentage,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO  events (name,description, type, privacy ,mode, country ,city , coordinates,google_map_link,location_instructions,virtual_meeting_link,capacity,virtual_meeting_platform,start_time,end_time,image_url,status) 
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17)
RETURNING id, name, description, type, privacy, mode, country, city, coordinates, google_map_link, location_instructions, virtual_meeting_platform, virtual_meeting_link, capacity, start_time, end_time, image_url, status, created_at, updated_at
`

type CreateEventParams struct {
	Name                   string
	Description            sql.NullString
	Type                   EventType
	Privacy                EventPrivacy
	Mode                   EventMode
	Country                sql.NullString
	City                   sql.NullString
	Coordinates            interface{}
	GoogleMapLink          sql.NullString
	LocationInstructions   sql.NullString
	VirtualMeetingLink     sql.NullString
	Capacity               sql.NullInt32
	VirtualMeetingPlatform sql.NullString
	StartTime              time.Time
	EndTime                time.Time
	ImageUrl               sql.NullString
	Status                 EventStatus
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, createEvent,
		arg.Name,
		arg.Description,
		arg.Type,
		arg.Privacy,
		arg.Mode,
		arg.Country,
		arg.City,
		arg.Coordinates,
		arg.GoogleMapLink,
		arg.LocationInstructions,
		arg.VirtualMeetingLink,
		arg.Capacity,
		arg.VirtualMeetingPlatform,
		arg.StartTime,
		arg.EndTime,
		arg.ImageUrl,
		arg.Status,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Type,
		&i.Privacy,
		&i.Mode,
		&i.Country,
		&i.City,
		&i.Coordinates,
		&i.GoogleMapLink,
		&i.LocationInstructions,
		&i.VirtualMeetingPlatform,
		&i.VirtualMeetingLink,
		&i.Capacity,
		&i.StartTime,
		&i.EndTime,
		&i.ImageUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEventCryptoPaymentOption = `-- name: CreateEventCryptoPaymentOption :one
INSERT INTO crypto_payment_options (
    event_id,  
    address_type,
    wallet,
    distribution_contract_address,
    chain_id,
    network_id
) VALUES (
    $1,  -- event_id (UUID)  -- payment_type, explicitly set to 'crypto' which is the default
    $2,  -- address_type
    $3,  -- wallet
    $4,  -- distribution_contract_address (nullable)
    $5,  -- chain_id
    $6  -- network_id
)
RETURNING id, event_id, address_type, wallet, distribution_contract_address, chain_id, network_id
`

type CreateEventCryptoPaymentOptionParams struct {
	EventID                     uuid.UUID
	AddressType                 AddressType
	Wallet                      sql.NullString
	DistributionContractAddress sql.NullString
	ChainID                     int32
	NetworkID                   int32
}

func (q *Queries) CreateEventCryptoPaymentOption(ctx context.Context, arg CreateEventCryptoPaymentOptionParams) (CryptoPaymentOption, error) {
	row := q.db.QueryRowContext(ctx, createEventCryptoPaymentOption,
		arg.EventID,
		arg.AddressType,
		arg.Wallet,
		arg.DistributionContractAddress,
		arg.ChainID,
		arg.NetworkID,
	)
	var i CryptoPaymentOption
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.AddressType,
		&i.Wallet,
		&i.DistributionContractAddress,
		&i.ChainID,
		&i.NetworkID,
	)
	return i, err
}

const createEventCryptoPaymentOptionTokens = `-- name: CreateEventCryptoPaymentOptionTokens :one
INSERT INTO crypto_payment_option_tokens (crypto_payment_option_id, network_id, token_id) 
VALUES ($1, $2, $3 )
RETURNING id, crypto_payment_option_id, network_id, token_id
`

type CreateEventCryptoPaymentOptionTokensParams struct {
	CryptoPaymentOptionID int32
	NetworkID             int32
	TokenID               int32
}

func (q *Queries) CreateEventCryptoPaymentOptionTokens(ctx context.Context, arg CreateEventCryptoPaymentOptionTokensParams) (CryptoPaymentOptionToken, error) {
	row := q.db.QueryRowContext(ctx, createEventCryptoPaymentOptionTokens, arg.CryptoPaymentOptionID, arg.NetworkID, arg.TokenID)
	var i CryptoPaymentOptionToken
	err := row.Scan(
		&i.ID,
		&i.CryptoPaymentOptionID,
		&i.NetworkID,
		&i.TokenID,
	)
	return i, err
}

const createEventTicket = `-- name: CreateEventTicket :one
INSERT INTO tickets (
    event_id, 
    ticket_type, 
    name,
    price, 
    max_scans
) VALUES (
    $1, $2, $3, $4,$5
) RETURNING id, event_id, name, ticket_type, price, max_scans, capacity, valid_from, valid_to
`

type CreateEventTicketParams struct {
	EventID    uuid.UUID
	TicketType TicketType
	Name       string
	Price      sql.NullString
	MaxScans   sql.NullInt32
}

func (q *Queries) CreateEventTicket(ctx context.Context, arg CreateEventTicketParams) (Ticket, error) {
	row := q.db.QueryRowContext(ctx, createEventTicket,
		arg.EventID,
		arg.TicketType,
		arg.Name,
		arg.Price,
		arg.MaxScans,
	)
	var i Ticket
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.Name,
		&i.TicketType,
		&i.Price,
		&i.MaxScans,
		&i.Capacity,
		&i.ValidFrom,
		&i.ValidTo,
	)
	return i, err
}

const createEventTicketPaymentOption = `-- name: CreateEventTicketPaymentOption :one
INSERT INTO ticket_crypto_payments (
    crypto_payment_option_id, 
    ticket_id
) VALUES (
    $1, $2
) RETURNING crypto_payment_option_id, ticket_id
`

type CreateEventTicketPaymentOptionParams struct {
	CryptoPaymentOptionID int32
	TicketID              int32
}

func (q *Queries) CreateEventTicketPaymentOption(ctx context.Context, arg CreateEventTicketPaymentOptionParams) (TicketCryptoPayment, error) {
	row := q.db.QueryRowContext(ctx, createEventTicketPaymentOption, arg.CryptoPaymentOptionID, arg.TicketID)
	var i TicketCryptoPayment
	err := row.Scan(&i.CryptoPaymentOptionID, &i.TicketID)
	return i, err
}

const createEventUser = `-- name: CreateEventUser :one
INSERT INTO  event_users (event_id, user_id,role) 
VALUES ($1,$2,$3)
RETURNING id
`

type CreateEventUserParams struct {
	EventID uuid.UUID
	UserID  uuid.UUID
	Role    RoleType
}

func (q *Queries) CreateEventUser(ctx context.Context, arg CreateEventUserParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, createEventUser, arg.EventID, arg.UserID, arg.Role)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createEventUserPaymentOptions = `-- name: CreateEventUserPaymentOptions :one
INSERT INTO  event_user_payment_options (event_user_id,payment_option_id) 
VALUES ($1,$2)
RETURNING id, event_user_id, payment_option_id
`

type CreateEventUserPaymentOptionsParams struct {
	EventUserID     int32
	PaymentOptionID int32
}

func (q *Queries) CreateEventUserPaymentOptions(ctx context.Context, arg CreateEventUserPaymentOptionsParams) (EventUserPaymentOption, error) {
	row := q.db.QueryRowContext(ctx, createEventUserPaymentOptions, arg.EventUserID, arg.PaymentOptionID)
	var i EventUserPaymentOption
	err := row.Scan(&i.ID, &i.EventUserID, &i.PaymentOptionID)
	return i, err
}

const createEventUserReq = `-- name: CreateEventUserReq :one
INSERT INTO event_users_req (user_id, event_id, role,token,split,expires_at) 
VALUES ($1, $2, $3 ,$4,$5,$6)
RETURNING id, user_id, event_id, role, token, response, split, expires_at, created_at, updated_at
`

type CreateEventUserReqParams struct {
	UserID    uuid.UUID
	EventID   uuid.UUID
	Role      RoleType
	Token     uuid.UUID
	Split     sql.NullString
	ExpiresAt time.Time
}

func (q *Queries) CreateEventUserReq(ctx context.Context, arg CreateEventUserReqParams) (EventUsersReq, error) {
	row := q.db.QueryRowContext(ctx, createEventUserReq,
		arg.UserID,
		arg.EventID,
		arg.Role,
		arg.Token,
		arg.Split,
		arg.ExpiresAt,
	)
	var i EventUsersReq
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.EventID,
		&i.Role,
		&i.Token,
		&i.Response,
		&i.Split,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTicketPurchase = `-- name: CreateTicketPurchase :one
INSERT INTO ticket_purchases (
    user_ticket_id, 
    payment_type, 
    wallet_address, 
    account_number, 
    user_id
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, user_ticket_id, payment_type, wallet_address, account_number, user_id
`

type CreateTicketPurchaseParams struct {
	UserTicketID  int32
	PaymentType   PaymentType
	WalletAddress sql.NullString
	AccountNumber sql.NullString
	UserID        uuid.UUID
}

func (q *Queries) CreateTicketPurchase(ctx context.Context, arg CreateTicketPurchaseParams) (TicketPurchase, error) {
	row := q.db.QueryRowContext(ctx, createTicketPurchase,
		arg.UserTicketID,
		arg.PaymentType,
		arg.WalletAddress,
		arg.AccountNumber,
		arg.UserID,
	)
	var i TicketPurchase
	err := row.Scan(
		&i.ID,
		&i.UserTicketID,
		&i.PaymentType,
		&i.WalletAddress,
		&i.AccountNumber,
		&i.UserID,
	)
	return i, err
}

const createUserCryptoPaymentOption = `-- name: CreateUserCryptoPaymentOption :one
INSERT INTO  user_payment_options (user_id,name,payment_type, wallet_id) 
VALUES ($1,$2,$3,$4)
RETURNING id,name,payment_type, wallet_id
`

type CreateUserCryptoPaymentOptionParams struct {
	UserID      uuid.UUID
	Name        sql.NullString
	PaymentType PaymentType
	WalletID    sql.NullInt32
}

type CreateUserCryptoPaymentOptionRow struct {
	ID          int32
	Name        sql.NullString
	PaymentType PaymentType
	WalletID    sql.NullInt32
}

func (q *Queries) CreateUserCryptoPaymentOption(ctx context.Context, arg CreateUserCryptoPaymentOptionParams) (CreateUserCryptoPaymentOptionRow, error) {
	row := q.db.QueryRowContext(ctx, createUserCryptoPaymentOption,
		arg.UserID,
		arg.Name,
		arg.PaymentType,
		arg.WalletID,
	)
	var i CreateUserCryptoPaymentOptionRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PaymentType,
		&i.WalletID,
	)
	return i, err
}

const createUserEmail = `-- name: CreateUserEmail :one
INSERT into user_emails (user_id,token, action_type ,expiry_date,is_completed)
VALUES ($1,$2,$3,$4,$5)
RETURNING id, user_id, token, action_type, expiry_date, is_completed
`

type CreateUserEmailParams struct {
	UserID      uuid.UUID
	Token       string
	ActionType  EmailActions
	ExpiryDate  time.Time
	IsCompleted bool
}

func (q *Queries) CreateUserEmail(ctx context.Context, arg CreateUserEmailParams) (UserEmail, error) {
	row := q.db.QueryRowContext(ctx, createUserEmail,
		arg.UserID,
		arg.Token,
		arg.ActionType,
		arg.ExpiryDate,
		arg.IsCompleted,
	)
	var i UserEmail
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ActionType,
		&i.ExpiryDate,
		&i.IsCompleted,
	)
	return i, err
}

const createUserEmailPassword = `-- name: CreateUserEmailPassword :one
INSERT INTO users (username,email,password,signup_type,subscription_type)
VALUES ($1,$2,$3,$4,$5)
RETURNING id, username, bio, email, password, is_email_verified, signup_type, subscription_type, wallet_linked, wallet_link_date, profile_image_url, cover_image_url, main_wallet_id, created_at, updated_at
`

type CreateUserEmailPasswordParams struct {
	Username         string
	Email            sql.NullString
	Password         sql.NullString
	SignupType       NullAccountType
	SubscriptionType string
}

func (q *Queries) CreateUserEmailPassword(ctx context.Context, arg CreateUserEmailPasswordParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUserEmailPassword,
		arg.Username,
		arg.Email,
		arg.Password,
		arg.SignupType,
		arg.SubscriptionType,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Bio,
		&i.Email,
		&i.Password,
		&i.IsEmailVerified,
		&i.SignupType,
		&i.SubscriptionType,
		&i.WalletLinked,
		&i.WalletLinkDate,
		&i.ProfileImageUrl,
		&i.CoverImageUrl,
		&i.MainWalletID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserSession = `-- name: CreateUserSession :one
INSERT INTO sessions (
    user_id,
    expires_at,
    ip_address,
    user_agent,
    created_at,
    last_accessed
) VALUES (
    $1, $2, $3, $4, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
) RETURNING id, user_id, created_at, expires_at, last_accessed, ip_address, user_agent
`

type CreateUserSessionParams struct {
	UserID    uuid.UUID
	ExpiresAt time.Time
	IpAddress sql.NullString
	UserAgent sql.NullString
}

func (q *Queries) CreateUserSession(ctx context.Context, arg CreateUserSessionParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, createUserSession,
		arg.UserID,
		arg.ExpiresAt,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastAccessed,
		&i.IpAddress,
		&i.UserAgent,
	)
	return i, err
}

const createUserSocial = `-- name: CreateUserSocial :one
INSERT INTO users (
    username,
    email,
    is_email_verified,
    signup_type,
    subscription_type,
    profile_image_url,
    bio,
    created_at,
    updated_at
) VALUES($1,$2,$3,$4,$5,$6,$7,CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
RETURNING id, username, bio, email, password, is_email_verified, signup_type, subscription_type, wallet_linked, wallet_link_date, profile_image_url, cover_image_url, main_wallet_id, created_at, updated_at
`

type CreateUserSocialParams struct {
	Username         string
	Email            sql.NullString
	IsEmailVerified  sql.NullBool
	SignupType       NullAccountType
	SubscriptionType string
	ProfileImageUrl  sql.NullString
	Bio              sql.NullString
}

func (q *Queries) CreateUserSocial(ctx context.Context, arg CreateUserSocialParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUserSocial,
		arg.Username,
		arg.Email,
		arg.IsEmailVerified,
		arg.SignupType,
		arg.SubscriptionType,
		arg.ProfileImageUrl,
		arg.Bio,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Bio,
		&i.Email,
		&i.Password,
		&i.IsEmailVerified,
		&i.SignupType,
		&i.SubscriptionType,
		&i.WalletLinked,
		&i.WalletLinkDate,
		&i.ProfileImageUrl,
		&i.CoverImageUrl,
		&i.MainWalletID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserSocialLogin = `-- name: CreateUserSocialLogin :one
INSERT INTO social_logins (
    user_id,
    provider_id,
    provider_user_id,
    access_token,
    refresh_token,
    created_at,
    updated_at,
    access_token_expiry
) VALUES (
    $1, $2, $3, $4, $5, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, $6
) RETURNING id, user_id, provider_id, provider_user_id, access_token, access_token_expiry, refresh_token, created_at, updated_at
`

type CreateUserSocialLoginParams struct {
	UserID            uuid.UUID
	ProviderID        int32
	ProviderUserID    string
	AccessToken       sql.NullString
	RefreshToken      sql.NullString
	AccessTokenExpiry sql.NullTime
}

func (q *Queries) CreateUserSocialLogin(ctx context.Context, arg CreateUserSocialLoginParams) (SocialLogin, error) {
	row := q.db.QueryRowContext(ctx, createUserSocialLogin,
		arg.UserID,
		arg.ProviderID,
		arg.ProviderUserID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.AccessTokenExpiry,
	)
	var i SocialLogin
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProviderID,
		&i.ProviderUserID,
		&i.AccessToken,
		&i.AccessTokenExpiry,
		&i.RefreshToken,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserTicket = `-- name: CreateUserTicket :one
INSERT INTO user_tickets (
    ticket_id, 
    user_id, 
    ticket_code, 
    scanned, 
    scan_count, 
    created_at, 
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP
) RETURNING id, ticket_id, user_id, ticket_code, scanned, scan_count, created_at, updated_at
`

type CreateUserTicketParams struct {
	TicketID   int32
	UserID     uuid.UUID
	TicketCode sql.NullString
	Scanned    sql.NullBool
	ScanCount  sql.NullInt32
}

func (q *Queries) CreateUserTicket(ctx context.Context, arg CreateUserTicketParams) (UserTicket, error) {
	row := q.db.QueryRowContext(ctx, createUserTicket,
		arg.TicketID,
		arg.UserID,
		arg.TicketCode,
		arg.Scanned,
		arg.ScanCount,
	)
	var i UserTicket
	err := row.Scan(
		&i.ID,
		&i.TicketID,
		&i.UserID,
		&i.TicketCode,
		&i.Scanned,
		&i.ScanCount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserWallet = `-- name: CreateUserWallet :one
INSERT INTO wallets (user_id, wallet_address, wallet_name, wallet_index, created_at, updated_at,chain_id) 
VALUES ($1,$2,$3,$4,$5,$6,$7)
RETURNING id,wallet_index,wallet_name,wallet_address
`

type CreateUserWalletParams struct {
	UserID        uuid.UUID
	WalletAddress string
	WalletName    string
	WalletIndex   int32
	CreatedAt     time.Time
	UpdatedAt     time.Time
	ChainID       int32
}

type CreateUserWalletRow struct {
	ID            int32
	WalletIndex   int32
	WalletName    string
	WalletAddress string
}

func (q *Queries) CreateUserWallet(ctx context.Context, arg CreateUserWalletParams) (CreateUserWalletRow, error) {
	row := q.db.QueryRowContext(ctx, createUserWallet,
		arg.UserID,
		arg.WalletAddress,
		arg.WalletName,
		arg.WalletIndex,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ChainID,
	)
	var i CreateUserWalletRow
	err := row.Scan(
		&i.ID,
		&i.WalletIndex,
		&i.WalletName,
		&i.WalletAddress,
	)
	return i, err
}

const deleteSessionByID = `-- name: DeleteSessionByID :exec
DELETE  FROM sessions
WHERE id = $1
`

// Deletes a session by its unique identifier.
func (q *Queries) DeleteSessionByID(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteSessionByID, id)
	return err
}

const deleteSessionByUserID = `-- name: DeleteSessionByUserID :exec
DELETE from sessions where user_id = $1
`

func (q *Queries) DeleteSessionByUserID(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteSessionByUserID, userID)
	return err
}

const getAllUsers = `-- name: GetAllUsers :many
SELECT id, username, bio, email, password, is_email_verified, signup_type, subscription_type, wallet_linked, wallet_link_date, profile_image_url, cover_image_url, main_wallet_id, created_at, updated_at FROM users
`

func (q *Queries) GetAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Bio,
			&i.Email,
			&i.Password,
			&i.IsEmailVerified,
			&i.SignupType,
			&i.SubscriptionType,
			&i.WalletLinked,
			&i.WalletLinkDate,
			&i.ProfileImageUrl,
			&i.CoverImageUrl,
			&i.MainWalletID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChains = `-- name: GetChains :many
SELECT id, name, description FROM chains
`

func (q *Queries) GetChains(ctx context.Context) ([]Chain, error) {
	rows, err := q.db.QueryContext(ctx, getChains)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Chain
	for rows.Next() {
		var i Chain
		if err := rows.Scan(&i.ID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCryptoPaymentOptionByEventID = `-- name: GetCryptoPaymentOptionByEventID :many
SELECT id, event_id, address_type, wallet, distribution_contract_address, chain_id, network_id FROM crypto_payment_options
WHERE event_id = $1
`

func (q *Queries) GetCryptoPaymentOptionByEventID(ctx context.Context, eventID uuid.UUID) ([]CryptoPaymentOption, error) {
	rows, err := q.db.QueryContext(ctx, getCryptoPaymentOptionByEventID, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CryptoPaymentOption
	for rows.Next() {
		var i CryptoPaymentOption
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.AddressType,
			&i.Wallet,
			&i.DistributionContractAddress,
			&i.ChainID,
			&i.NetworkID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCryptoPaymentTokensByPaymentID = `-- name: GetCryptoPaymentTokensByPaymentID :many
SELECT 
    cpt.id,
    cpt.crypto_payment_option_id,
    cpt.token_id,
    t.name AS token_name
FROM 
    crypto_payment_option_tokens cpt
JOIN 
    tokens t ON cpt.token_id = t.id
WHERE 
    cpt.crypto_payment_option_id = $1
`

type GetCryptoPaymentTokensByPaymentIDRow struct {
	ID                    int32
	CryptoPaymentOptionID int32
	TokenID               int32
	TokenName             string
}

func (q *Queries) GetCryptoPaymentTokensByPaymentID(ctx context.Context, cryptoPaymentOptionID int32) ([]GetCryptoPaymentTokensByPaymentIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getCryptoPaymentTokensByPaymentID, cryptoPaymentOptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCryptoPaymentTokensByPaymentIDRow
	for rows.Next() {
		var i GetCryptoPaymentTokensByPaymentIDRow
		if err := rows.Scan(
			&i.ID,
			&i.CryptoPaymentOptionID,
			&i.TokenID,
			&i.TokenName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistributionById = `-- name: GetDistributionById :one
SELECT id, network_id, crypto_payment_option_id, description, created_at, updated_at 
FROM distributions 
WHERE id = $1
`

func (q *Queries) GetDistributionById(ctx context.Context, id int32) (Distribution, error) {
	row := q.db.QueryRowContext(ctx, getDistributionById, id)
	var i Distribution
	err := row.Scan(
		&i.ID,
		&i.NetworkID,
		&i.CryptoPaymentOptionID,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDistributionContractByNetworkID = `-- name: GetDistributionContractByNetworkID :one
SELECT distribution_contract_address
FROM networks
WHERE id = $1
`

func (q *Queries) GetDistributionContractByNetworkID(ctx context.Context, id int32) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getDistributionContractByNetworkID, id)
	var distribution_contract_address sql.NullString
	err := row.Scan(&distribution_contract_address)
	return distribution_contract_address, err
}

const getDistributionParams = `-- name: GetDistributionParams :many
SELECT 
    e.name AS event_name,
    e.description AS event_description,
    cpo.chain_id,
    copt.token_id,
    ds.name AS distributor_name,
    ds.wallet_address,
    ds.split_percentage
FROM 
    events e
LEFT JOIN 
    crypto_payment_options cpo ON e.id = cpo.event_id
LEFT JOIN 
    crypto_payment_option_tokens copt ON cpo.id = copt.crypto_payment_option_id
LEFT JOIN 
    distributions d ON cpo.id = d.crypto_payment_option_id
LEFT JOIN 
    distribution_splits ds ON d.id = ds.distribution_id
WHERE 
    cpo.id = $1
`

type GetDistributionParamsRow struct {
	EventName        string
	EventDescription sql.NullString
	ChainID          sql.NullInt32
	TokenID          sql.NullInt32
	DistributorName  sql.NullString
	WalletAddress    sql.NullString
	SplitPercentage  sql.NullString
}

func (q *Queries) GetDistributionParams(ctx context.Context, id int32) ([]GetDistributionParamsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDistributionParams, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDistributionParamsRow
	for rows.Next() {
		var i GetDistributionParamsRow
		if err := rows.Scan(
			&i.EventName,
			&i.EventDescription,
			&i.ChainID,
			&i.TokenID,
			&i.DistributorName,
			&i.WalletAddress,
			&i.SplitPercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistributionSplitsByDistributionId = `-- name: GetDistributionSplitsByDistributionId :many
SELECT 
    ds.id,
    ds.distribution_id,
    ds.wallet_address,
    ds.name,
    ds.split_percentage,
    ds.created_at,
    ds.updated_at,
    d.description AS distribution_description -- Example of fetching additional data from distributions table
FROM 
    distribution_splits ds
JOIN 
    distributions d ON ds.distribution_id = d.id
WHERE 
    ds.distribution_id = $1
`

type GetDistributionSplitsByDistributionIdRow struct {
	ID                      int32
	DistributionID          int32
	WalletAddress           string
	Name                    sql.NullString
	SplitPercentage         string
	CreatedAt               sql.NullTime
	UpdatedAt               sql.NullTime
	DistributionDescription sql.NullString
}

func (q *Queries) GetDistributionSplitsByDistributionId(ctx context.Context, distributionID int32) ([]GetDistributionSplitsByDistributionIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getDistributionSplitsByDistributionId, distributionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDistributionSplitsByDistributionIdRow
	for rows.Next() {
		var i GetDistributionSplitsByDistributionIdRow
		if err := rows.Scan(
			&i.ID,
			&i.DistributionID,
			&i.WalletAddress,
			&i.Name,
			&i.SplitPercentage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DistributionDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDistributionsByPaymentId = `-- name: GetDistributionsByPaymentId :many
SELECT id, network_id, crypto_payment_option_id, description, created_at, updated_at 
FROM distributions 
WHERE crypto_payment_option_id = $1
`

func (q *Queries) GetDistributionsByPaymentId(ctx context.Context, cryptoPaymentOptionID int32) ([]Distribution, error) {
	rows, err := q.db.QueryContext(ctx, getDistributionsByPaymentId, cryptoPaymentOptionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Distribution
	for rows.Next() {
		var i Distribution
		if err := rows.Scan(
			&i.ID,
			&i.NetworkID,
			&i.CryptoPaymentOptionID,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmailToken = `-- name: GetEmailToken :one
SELECT user_id FROM user_emails WHERE token = $1 AND expiry_date > CURRENT_TIMESTAMP
`

func (q *Queries) GetEmailToken(ctx context.Context, token string) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getEmailToken, token)
	var user_id uuid.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const getEventCollaboratorPaymentOptions = `-- name: GetEventCollaboratorPaymentOptions :many
SELECT  eu.id as collaborator_id, eupo.payment_option_id as payment_option_id
FROM  events e
INNER JOIN event_users eu ON e.id = eu.event_id
INNER JOIN event_user_payment_options eupo ON eu.id = eupo.event_user_id
WHERE e.id = $1
`

type GetEventCollaboratorPaymentOptionsRow struct {
	CollaboratorID  int32
	PaymentOptionID int32
}

func (q *Queries) GetEventCollaboratorPaymentOptions(ctx context.Context, id uuid.UUID) ([]GetEventCollaboratorPaymentOptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventCollaboratorPaymentOptions, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventCollaboratorPaymentOptionsRow
	for rows.Next() {
		var i GetEventCollaboratorPaymentOptionsRow
		if err := rows.Scan(&i.CollaboratorID, &i.PaymentOptionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventTicketPaymentOption = `-- name: GetEventTicketPaymentOption :many
SELECT crypto_payment_option_id, ticket_id 
FROM ticket_crypto_payments
WHERE ticket_id = $1
`

func (q *Queries) GetEventTicketPaymentOption(ctx context.Context, ticketID int32) ([]TicketCryptoPayment, error) {
	rows, err := q.db.QueryContext(ctx, getEventTicketPaymentOption, ticketID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TicketCryptoPayment
	for rows.Next() {
		var i TicketCryptoPayment
		if err := rows.Scan(&i.CryptoPaymentOptionID, &i.TicketID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventTickets = `-- name: GetEventTickets :many
SELECT id, event_id, name, ticket_type, price, max_scans, capacity, valid_from, valid_to 
FROM tickets
WHERE event_id = $1
`

func (q *Queries) GetEventTickets(ctx context.Context, eventID uuid.UUID) ([]Ticket, error) {
	rows, err := q.db.QueryContext(ctx, getEventTickets, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Ticket
	for rows.Next() {
		var i Ticket
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.Name,
			&i.TicketType,
			&i.Price,
			&i.MaxScans,
			&i.Capacity,
			&i.ValidFrom,
			&i.ValidTo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventUsers = `-- name: GetEventUsers :many
SELECT id, event_id, user_id, role, created_at, updated_at FROM  event_users 
WHERE event_id = $1
`

func (q *Queries) GetEventUsers(ctx context.Context, eventID uuid.UUID) ([]EventUser, error) {
	rows, err := q.db.QueryContext(ctx, getEventUsers, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventUser
	for rows.Next() {
		var i EventUser
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.UserID,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNetworksByChain = `-- name: GetNetworksByChain :many
SELECT id, chain_id, name, distribution_contract_address FROM networks
WHERE chain_id = $1
`

func (q *Queries) GetNetworksByChain(ctx context.Context, chainID int32) ([]Network, error) {
	rows, err := q.db.QueryContext(ctx, getNetworksByChain, chainID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Network
	for rows.Next() {
		var i Network
		if err := rows.Scan(
			&i.ID,
			&i.ChainID,
			&i.Name,
			&i.DistributionContractAddress,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, user_id, created_at, expires_at, last_accessed, ip_address, user_agent FROM sessions
WHERE id = $1
`

// Retrieves a session by its unique identifier.
func (q *Queries) GetSessionByID(ctx context.Context, id uuid.UUID) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastAccessed,
		&i.IpAddress,
		&i.UserAgent,
	)
	return i, err
}

const getSessionByUserID = `-- name: GetSessionByUserID :one
SELECT id, user_id, created_at, expires_at, last_accessed, ip_address, user_agent FROM sessions
WHERE user_id = $1 AND expires_at > CURRENT_TIMESTAMP
`

func (q *Queries) GetSessionByUserID(ctx context.Context, userID uuid.UUID) (Session, error) {
	row := q.db.QueryRowContext(ctx, getSessionByUserID, userID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastAccessed,
		&i.IpAddress,
		&i.UserAgent,
	)
	return i, err
}

const getSocialLoginUserByID = `-- name: GetSocialLoginUserByID :one
SELECT user_id FROM social_logins WHERE provider_user_id = $1
`

func (q *Queries) GetSocialLoginUserByID(ctx context.Context, providerUserID string) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, getSocialLoginUserByID, providerUserID)
	var user_id uuid.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const getTokenNetworkAddresses = `-- name: GetTokenNetworkAddresses :many
SELECT 
    tna.id,
    t.name AS token_name,
    n.name AS network_name,
    tna.address
FROM token_network_address tna
JOIN tokens t ON tna.token_id = t.id
JOIN networks n ON tna.network_id = n.id
`

type GetTokenNetworkAddressesRow struct {
	ID          int32
	TokenName   string
	NetworkName string
	Address     string
}

func (q *Queries) GetTokenNetworkAddresses(ctx context.Context) ([]GetTokenNetworkAddressesRow, error) {
	rows, err := q.db.QueryContext(ctx, getTokenNetworkAddresses)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTokenNetworkAddressesRow
	for rows.Next() {
		var i GetTokenNetworkAddressesRow
		if err := rows.Scan(
			&i.ID,
			&i.TokenName,
			&i.NetworkName,
			&i.Address,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, bio, email, password, is_email_verified, signup_type, subscription_type, wallet_linked, wallet_link_date, profile_image_url, cover_image_url, main_wallet_id, created_at, updated_at FROM users WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Bio,
		&i.Email,
		&i.Password,
		&i.IsEmailVerified,
		&i.SignupType,
		&i.SubscriptionType,
		&i.WalletLinked,
		&i.WalletLinkDate,
		&i.ProfileImageUrl,
		&i.CoverImageUrl,
		&i.MainWalletID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, bio, email, password, is_email_verified, signup_type, subscription_type, wallet_linked, wallet_link_date, profile_image_url, cover_image_url, main_wallet_id, created_at, updated_at FROM users WHERE username = $1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Bio,
		&i.Email,
		&i.Password,
		&i.IsEmailVerified,
		&i.SignupType,
		&i.SubscriptionType,
		&i.WalletLinked,
		&i.WalletLinkDate,
		&i.ProfileImageUrl,
		&i.CoverImageUrl,
		&i.MainWalletID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserEmail = `-- name: GetUserEmail :one
SELECT id, username, bio, email, password, is_email_verified, signup_type, subscription_type, wallet_linked, wallet_link_date, profile_image_url, cover_image_url, main_wallet_id, created_at, updated_at FROM users WHERE email = $1
`

func (q *Queries) GetUserEmail(ctx context.Context, email sql.NullString) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Bio,
		&i.Email,
		&i.Password,
		&i.IsEmailVerified,
		&i.SignupType,
		&i.SubscriptionType,
		&i.WalletLinked,
		&i.WalletLinkDate,
		&i.ProfileImageUrl,
		&i.CoverImageUrl,
		&i.MainWalletID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserEmailById = `-- name: GetUserEmailById :one
SELECT email FROM users WHERE id = $1
`

func (q *Queries) GetUserEmailById(ctx context.Context, id uuid.UUID) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getUserEmailById, id)
	var email sql.NullString
	err := row.Scan(&email)
	return email, err
}

const getUserEvents = `-- name: GetUserEvents :many
SELECT e.id as event_id , e.name as event_name, eu.role as role  FROM  events e
inner join event_users eu
on e.id = eu.event_id
WHERE user_id = $1
`

type GetUserEventsRow struct {
	EventID   uuid.UUID
	EventName string
	Role      RoleType
}

func (q *Queries) GetUserEvents(ctx context.Context, userID uuid.UUID) ([]GetUserEventsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserEvents, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserEventsRow
	for rows.Next() {
		var i GetUserEventsRow
		if err := rows.Scan(&i.EventID, &i.EventName, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEventsAll = `-- name: GetUserEventsAll :many
SELECT e.id, name, description, type, privacy, mode, country, city, coordinates, google_map_link, location_instructions, virtual_meeting_platform, virtual_meeting_link, capacity, start_time, end_time, image_url, status, e.created_at, e.updated_at, eu.id, event_id, user_id, role, eu.created_at, eu.updated_at From events e
inner join event_users eu
on e.id = eu.event_id
WHERE user_id = $1
`

type GetUserEventsAllRow struct {
	ID                     uuid.UUID
	Name                   string
	Description            sql.NullString
	Type                   EventType
	Privacy                EventPrivacy
	Mode                   EventMode
	Country                sql.NullString
	City                   sql.NullString
	Coordinates            interface{}
	GoogleMapLink          sql.NullString
	LocationInstructions   sql.NullString
	VirtualMeetingPlatform sql.NullString
	VirtualMeetingLink     sql.NullString
	Capacity               sql.NullInt32
	StartTime              time.Time
	EndTime                time.Time
	ImageUrl               sql.NullString
	Status                 EventStatus
	CreatedAt              time.Time
	UpdatedAt              time.Time
	ID_2                   int32
	EventID                uuid.UUID
	UserID                 uuid.UUID
	Role                   RoleType
	CreatedAt_2            sql.NullTime
	UpdatedAt_2            sql.NullTime
}

func (q *Queries) GetUserEventsAll(ctx context.Context, userID uuid.UUID) ([]GetUserEventsAllRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserEventsAll, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserEventsAllRow
	for rows.Next() {
		var i GetUserEventsAllRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Type,
			&i.Privacy,
			&i.Mode,
			&i.Country,
			&i.City,
			&i.Coordinates,
			&i.GoogleMapLink,
			&i.LocationInstructions,
			&i.VirtualMeetingPlatform,
			&i.VirtualMeetingLink,
			&i.Capacity,
			&i.StartTime,
			&i.EndTime,
			&i.ImageUrl,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.EventID,
			&i.UserID,
			&i.Role,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPaymentOptions = `-- name: GetUserPaymentOptions :many
SELECT id, user_id, name, payment_type, card_id, wallet_id FROM  user_payment_options
WHERE user_id = $1
`

func (q *Queries) GetUserPaymentOptions(ctx context.Context, userID uuid.UUID) ([]UserPaymentOption, error) {
	rows, err := q.db.QueryContext(ctx, getUserPaymentOptions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserPaymentOption
	for rows.Next() {
		var i UserPaymentOption
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.PaymentType,
			&i.CardID,
			&i.WalletID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTicketPurchase = `-- name: GetUserTicketPurchase :many
SELECT tp.id, tp.user_ticket_id, tp.payment_type, tp.wallet_address, tp.account_number, tp.user_id, ut.id, ut.ticket_id, ut.user_id, ut.ticket_code, ut.scanned, ut.scan_count, ut.created_at, ut.updated_at
FROM ticket_purchases tp
JOIN user_tickets ut ON tp.user_ticket_id = ut.id
WHERE ut.user_id = $1
`

type GetUserTicketPurchaseRow struct {
	ID            uuid.UUID
	UserTicketID  int32
	PaymentType   PaymentType
	WalletAddress sql.NullString
	AccountNumber sql.NullString
	UserID        uuid.UUID
	ID_2          int32
	TicketID      int32
	UserID_2      uuid.UUID
	TicketCode    sql.NullString
	Scanned       sql.NullBool
	ScanCount     sql.NullInt32
	CreatedAt     sql.NullTime
	UpdatedAt     sql.NullTime
}

func (q *Queries) GetUserTicketPurchase(ctx context.Context, userID uuid.UUID) ([]GetUserTicketPurchaseRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserTicketPurchase, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserTicketPurchaseRow
	for rows.Next() {
		var i GetUserTicketPurchaseRow
		if err := rows.Scan(
			&i.ID,
			&i.UserTicketID,
			&i.PaymentType,
			&i.WalletAddress,
			&i.AccountNumber,
			&i.UserID,
			&i.ID_2,
			&i.TicketID,
			&i.UserID_2,
			&i.TicketCode,
			&i.Scanned,
			&i.ScanCount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTickets = `-- name: GetUserTickets :many
SELECT ut.id, ut.ticket_id, ut.user_id, ut.ticket_code, ut.scanned, ut.scan_count, ut.created_at, ut.updated_at, t.id, t.event_id, t.name, t.ticket_type, t.price, t.max_scans, t.capacity, t.valid_from, t.valid_to
FROM user_tickets ut
JOIN tickets t ON ut.ticket_id = t.id
WHERE ut.user_id = $1
`

type GetUserTicketsRow struct {
	ID         int32
	TicketID   int32
	UserID     uuid.UUID
	TicketCode sql.NullString
	Scanned    sql.NullBool
	ScanCount  sql.NullInt32
	CreatedAt  sql.NullTime
	UpdatedAt  sql.NullTime
	ID_2       int32
	EventID    uuid.UUID
	Name       string
	TicketType TicketType
	Price      sql.NullString
	MaxScans   sql.NullInt32
	Capacity   sql.NullInt32
	ValidFrom  sql.NullTime
	ValidTo    sql.NullTime
}

func (q *Queries) GetUserTickets(ctx context.Context, userID uuid.UUID) ([]GetUserTicketsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserTickets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserTicketsRow
	for rows.Next() {
		var i GetUserTicketsRow
		if err := rows.Scan(
			&i.ID,
			&i.TicketID,
			&i.UserID,
			&i.TicketCode,
			&i.Scanned,
			&i.ScanCount,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.EventID,
			&i.Name,
			&i.TicketType,
			&i.Price,
			&i.MaxScans,
			&i.Capacity,
			&i.ValidFrom,
			&i.ValidTo,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWallet = `-- name: GetUserWallet :one
SELECT id, user_id, wallet_address, wallet_name, wallet_index, created_at, updated_at, chain_id
		FROM wallets
		WHERE user_id = $1
		ORDER BY created_at ASC
		LIMIT 1
`

func (q *Queries) GetUserWallet(ctx context.Context, userID uuid.UUID) (Wallet, error) {
	row := q.db.QueryRowContext(ctx, getUserWallet, userID)
	var i Wallet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WalletAddress,
		&i.WalletName,
		&i.WalletIndex,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ChainID,
	)
	return i, err
}

const getUserWallets = `-- name: GetUserWallets :many
SELECT id, user_id, wallet_address, wallet_name, wallet_index, created_at, updated_at, chain_id FROM  wallets
WHERE user_id = $1
`

func (q *Queries) GetUserWallets(ctx context.Context, userID uuid.UUID) ([]Wallet, error) {
	rows, err := q.db.QueryContext(ctx, getUserWallets, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Wallet
	for rows.Next() {
		var i Wallet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.WalletAddress,
			&i.WalletName,
			&i.WalletIndex,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ChainID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const gettUsersession = `-- name: GettUsersession :one
SELECT id, user_id, created_at, expires_at, last_accessed, ip_address, user_agent FROM sessions
WHERE user_id = $1 AND expires_at > CURRENT_TIMESTAMP
`

// scheck expiry
func (q *Queries) GettUsersession(ctx context.Context, userID uuid.UUID) (Session, error) {
	row := q.db.QueryRowContext(ctx, gettUsersession, userID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.LastAccessed,
		&i.IpAddress,
		&i.UserAgent,
	)
	return i, err
}

const newCreateEvent = `-- name: NewCreateEvent :one
INSERT INTO  events (name,description, type, privacy ,mode, country ,city,google_map_link,location_instructions,virtual_meeting_link,capacity,virtual_meeting_platform,start_time,end_time,image_url,status) 
VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16)
RETURNING id, name, description, type, privacy, mode, country, city, coordinates, google_map_link, location_instructions, virtual_meeting_platform, virtual_meeting_link, capacity, start_time, end_time, image_url, status, created_at, updated_at
`

type NewCreateEventParams struct {
	Name                   string
	Description            sql.NullString
	Type                   EventType
	Privacy                EventPrivacy
	Mode                   EventMode
	Country                sql.NullString
	City                   sql.NullString
	GoogleMapLink          sql.NullString
	LocationInstructions   sql.NullString
	VirtualMeetingLink     sql.NullString
	Capacity               sql.NullInt32
	VirtualMeetingPlatform sql.NullString
	StartTime              time.Time
	EndTime                time.Time
	ImageUrl               sql.NullString
	Status                 EventStatus
}

func (q *Queries) NewCreateEvent(ctx context.Context, arg NewCreateEventParams) (Event, error) {
	row := q.db.QueryRowContext(ctx, newCreateEvent,
		arg.Name,
		arg.Description,
		arg.Type,
		arg.Privacy,
		arg.Mode,
		arg.Country,
		arg.City,
		arg.GoogleMapLink,
		arg.LocationInstructions,
		arg.VirtualMeetingLink,
		arg.Capacity,
		arg.VirtualMeetingPlatform,
		arg.StartTime,
		arg.EndTime,
		arg.ImageUrl,
		arg.Status,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Type,
		&i.Privacy,
		&i.Mode,
		&i.Country,
		&i.City,
		&i.Coordinates,
		&i.GoogleMapLink,
		&i.LocationInstructions,
		&i.VirtualMeetingPlatform,
		&i.VirtualMeetingLink,
		&i.Capacity,
		&i.StartTime,
		&i.EndTime,
		&i.ImageUrl,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCryptoPaymentOptionWithDistribution = `-- name: UpdateCryptoPaymentOptionWithDistribution :exec
UPDATE crypto_payment_options
SET address_type = $2, distribution_contract_address = $3
WHERE id = $1
`

type UpdateCryptoPaymentOptionWithDistributionParams struct {
	ID                          int32
	AddressType                 AddressType
	DistributionContractAddress sql.NullString
}

func (q *Queries) UpdateCryptoPaymentOptionWithDistribution(ctx context.Context, arg UpdateCryptoPaymentOptionWithDistributionParams) error {
	_, err := q.db.ExecContext(ctx, updateCryptoPaymentOptionWithDistribution, arg.ID, arg.AddressType, arg.DistributionContractAddress)
	return err
}

const updateEmailVerification = `-- name: UpdateEmailVerification :exec
UPDATE users SET is_email_verified = $2
WHERE id = $1
`

type UpdateEmailVerificationParams struct {
	ID              uuid.UUID
	IsEmailVerified sql.NullBool
}

func (q *Queries) UpdateEmailVerification(ctx context.Context, arg UpdateEmailVerificationParams) error {
	_, err := q.db.ExecContext(ctx, updateEmailVerification, arg.ID, arg.IsEmailVerified)
	return err
}

const updateEventImage = `-- name: UpdateEventImage :exec
UPDATE events 
SET 
    image_url = $2
WHERE 
    id = $1
`

type UpdateEventImageParams struct {
	ID       uuid.UUID
	ImageUrl sql.NullString
}

func (q *Queries) UpdateEventImage(ctx context.Context, arg UpdateEventImageParams) error {
	_, err := q.db.ExecContext(ctx, updateEventImage, arg.ID, arg.ImageUrl)
	return err
}

const updateUserEmail = `-- name: UpdateUserEmail :exec
UPDATE users Set is_email_verified = $2
WHERE id = $1
`

type UpdateUserEmailParams struct {
	ID              uuid.UUID
	IsEmailVerified sql.NullBool
}

func (q *Queries) UpdateUserEmail(ctx context.Context, arg UpdateUserEmailParams) error {
	_, err := q.db.ExecContext(ctx, updateUserEmail, arg.ID, arg.IsEmailVerified)
	return err
}

const updateUserMainWallet = `-- name: UpdateUserMainWallet :exec
UPDATE users Set main_wallet_id = $2, wallet_linked = true, wallet_link_date = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateUserMainWalletParams struct {
	ID           uuid.UUID
	MainWalletID sql.NullInt32
}

func (q *Queries) UpdateUserMainWallet(ctx context.Context, arg UpdateUserMainWalletParams) error {
	_, err := q.db.ExecContext(ctx, updateUserMainWallet, arg.ID, arg.MainWalletID)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users Set password = $2
WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID       uuid.UUID
	Password sql.NullString
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.ID, arg.Password)
	return err
}

const updateUserProfileImage = `-- name: UpdateUserProfileImage :exec
UPDATE users 
SET 
    profile_image_url= $2
WHERE 
    id = $1
`

type UpdateUserProfileImageParams struct {
	ID              uuid.UUID
	ProfileImageUrl sql.NullString
}

func (q *Queries) UpdateUserProfileImage(ctx context.Context, arg UpdateUserProfileImageParams) error {
	_, err := q.db.ExecContext(ctx, updateUserProfileImage, arg.ID, arg.ProfileImageUrl)
	return err
}

const updateUserUsername = `-- name: UpdateUserUsername :exec
UPDATE users Set username = $2
WHERE id = $1
`

type UpdateUserUsernameParams struct {
	ID       uuid.UUID
	Username string
}

func (q *Queries) UpdateUserUsername(ctx context.Context, arg UpdateUserUsernameParams) error {
	_, err := q.db.ExecContext(ctx, updateUserUsername, arg.ID, arg.Username)
	return err
}

const updateUserWithWalletLink = `-- name: UpdateUserWithWalletLink :exec
UPDATE users 
SET 
    main_wallet_id = $1, 
    wallet_linked = TRUE, 
    wallet_link_date = CURRENT_TIMESTAMP 
WHERE 
    id = $2
`

type UpdateUserWithWalletLinkParams struct {
	MainWalletID sql.NullInt32
	ID           uuid.UUID
}

func (q *Queries) UpdateUserWithWalletLink(ctx context.Context, arg UpdateUserWithWalletLinkParams) error {
	_, err := q.db.ExecContext(ctx, updateUserWithWalletLink, arg.MainWalletID, arg.ID)
	return err
}
